// This file was generated by Conjure and should not be manually edited.

package actions

import (
	"strings"
)

type CallStatus struct {
	val CallStatus_Value
}

type CallStatus_Value string

const (
	CallStatus_SUBMITTED CallStatus_Value = "SUBMITTED"
	CallStatus_SUCCEEDED CallStatus_Value = "SUCCEEDED"
	CallStatus_FAILED    CallStatus_Value = "FAILED"
	CallStatus_UNKNOWN   CallStatus_Value = "UNKNOWN"
)

// CallStatus_Values returns all known variants of CallStatus.
func CallStatus_Values() []CallStatus_Value {
	return []CallStatus_Value{CallStatus_SUBMITTED, CallStatus_SUCCEEDED, CallStatus_FAILED}
}

func New_CallStatus(value CallStatus_Value) CallStatus {
	return CallStatus{val: value}
}

// IsUnknown returns false for all known variants of CallStatus and true otherwise.
func (e CallStatus) IsUnknown() bool {
	switch e.val {
	case CallStatus_SUBMITTED, CallStatus_SUCCEEDED, CallStatus_FAILED:
		return false
	}
	return true
}

func (e CallStatus) Value() CallStatus_Value {
	if e.IsUnknown() {
		return CallStatus_UNKNOWN
	}
	return e.val
}

func (e CallStatus) String() string {
	return string(e.val)
}

func (e CallStatus) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *CallStatus) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_CallStatus(CallStatus_Value(v))
	case "SUBMITTED":
		*e = New_CallStatus(CallStatus_SUBMITTED)
	case "SUCCEEDED":
		*e = New_CallStatus(CallStatus_SUCCEEDED)
	case "FAILED":
		*e = New_CallStatus(CallStatus_FAILED)
	}
	return nil
}

// What project storage should be available for this execution. Empty storage means this execution will have a
// clean slate. Copy on write means execution will read from project storage and writes will be saved to an
// isolated storage. Write means execution will write to project storage.
type CallStorageType struct {
	val CallStorageType_Value
}

// What project storage should be available for this execution. Empty storage means this execution will have a
// clean slate. Copy on write means execution will read from project storage and writes will be saved to an
// isolated storage. Write means execution will write to project storage.
type CallStorageType_Value string

const (
	CallStorageType_EMPTY         CallStorageType_Value = "EMPTY"
	CallStorageType_COPY_ON_WRITE CallStorageType_Value = "COPY_ON_WRITE"
	CallStorageType_WRITE         CallStorageType_Value = "WRITE"
	CallStorageType_UNKNOWN       CallStorageType_Value = "UNKNOWN"
)

// CallStorageType_Values returns all known variants of CallStorageType.
func CallStorageType_Values() []CallStorageType_Value {
	return []CallStorageType_Value{CallStorageType_EMPTY, CallStorageType_COPY_ON_WRITE, CallStorageType_WRITE}
}

func New_CallStorageType(value CallStorageType_Value) CallStorageType {
	return CallStorageType{val: value}
}

// IsUnknown returns false for all known variants of CallStorageType and true otherwise.
func (e CallStorageType) IsUnknown() bool {
	switch e.val {
	case CallStorageType_EMPTY, CallStorageType_COPY_ON_WRITE, CallStorageType_WRITE:
		return false
	}
	return true
}

func (e CallStorageType) Value() CallStorageType_Value {
	if e.IsUnknown() {
		return CallStorageType_UNKNOWN
	}
	return e.val
}

func (e CallStorageType) String() string {
	return string(e.val)
}

func (e CallStorageType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *CallStorageType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_CallStorageType(CallStorageType_Value(v))
	case "EMPTY":
		*e = New_CallStorageType(CallStorageType_EMPTY)
	case "COPY_ON_WRITE":
		*e = New_CallStorageType(CallStorageType_COPY_ON_WRITE)
	case "WRITE":
		*e = New_CallStorageType(CallStorageType_WRITE)
	}
	return nil
}

// Test calls are created through call endpoint. Triggered calls are created automatically by defined trigger.
type CallType struct {
	val CallType_Value
}

// Test calls are created through call endpoint. Triggered calls are created automatically by defined trigger.
type CallType_Value string

const (
	CallType_MANUAL    CallType_Value = "MANUAL"
	CallType_AUTOMATIC CallType_Value = "AUTOMATIC"
	CallType_UNKNOWN   CallType_Value = "UNKNOWN"
)

// CallType_Values returns all known variants of CallType.
func CallType_Values() []CallType_Value {
	return []CallType_Value{CallType_MANUAL, CallType_AUTOMATIC}
}

func New_CallType(value CallType_Value) CallType {
	return CallType{val: value}
}

// IsUnknown returns false for all known variants of CallType and true otherwise.
func (e CallType) IsUnknown() bool {
	switch e.val {
	case CallType_MANUAL, CallType_AUTOMATIC:
		return false
	}
	return true
}

func (e CallType) Value() CallType_Value {
	if e.IsUnknown() {
		return CallType_UNKNOWN
	}
	return e.val
}

func (e CallType) String() string {
	return string(e.val)
}

func (e CallType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *CallType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_CallType(CallType_Value(v))
	case "MANUAL":
		*e = New_CallType(CallType_MANUAL)
	case "AUTOMATIC":
		*e = New_CallType(CallType_AUTOMATIC)
	}
	return nil
}

type ContractInvocationType struct {
	val ContractInvocationType_Value
}

type ContractInvocationType_Value string

const (
	ContractInvocationType_ANY      ContractInvocationType_Value = "ANY"
	ContractInvocationType_DIRECT   ContractInvocationType_Value = "DIRECT"
	ContractInvocationType_INTERNAL ContractInvocationType_Value = "INTERNAL"
	ContractInvocationType_UNKNOWN  ContractInvocationType_Value = "UNKNOWN"
)

// ContractInvocationType_Values returns all known variants of ContractInvocationType.
func ContractInvocationType_Values() []ContractInvocationType_Value {
	return []ContractInvocationType_Value{ContractInvocationType_ANY, ContractInvocationType_DIRECT, ContractInvocationType_INTERNAL}
}

func New_ContractInvocationType(value ContractInvocationType_Value) ContractInvocationType {
	return ContractInvocationType{val: value}
}

// IsUnknown returns false for all known variants of ContractInvocationType and true otherwise.
func (e ContractInvocationType) IsUnknown() bool {
	switch e.val {
	case ContractInvocationType_ANY, ContractInvocationType_DIRECT, ContractInvocationType_INTERNAL:
		return false
	}
	return true
}

func (e ContractInvocationType) Value() ContractInvocationType_Value {
	if e.IsUnknown() {
		return ContractInvocationType_UNKNOWN
	}
	return e.val
}

func (e ContractInvocationType) String() string {
	return string(e.val)
}

func (e ContractInvocationType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *ContractInvocationType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_ContractInvocationType(ContractInvocationType_Value(v))
	case "ANY":
		*e = New_ContractInvocationType(ContractInvocationType_ANY)
	case "DIRECT":
		*e = New_ContractInvocationType(ContractInvocationType_DIRECT)
	case "INTERNAL":
		*e = New_ContractInvocationType(ContractInvocationType_INTERNAL)
	}
	return nil
}

type DeployStatus struct {
	val DeployStatus_Value
}

type DeployStatus_Value string

const (
	DeployStatus_PUBLISHED DeployStatus_Value = "PUBLISHED"
	DeployStatus_DEPLOYED  DeployStatus_Value = "DEPLOYED"
	DeployStatus_UNKNOWN   DeployStatus_Value = "UNKNOWN"
)

// DeployStatus_Values returns all known variants of DeployStatus.
func DeployStatus_Values() []DeployStatus_Value {
	return []DeployStatus_Value{DeployStatus_PUBLISHED, DeployStatus_DEPLOYED}
}

func New_DeployStatus(value DeployStatus_Value) DeployStatus {
	return DeployStatus{val: value}
}

// IsUnknown returns false for all known variants of DeployStatus and true otherwise.
func (e DeployStatus) IsUnknown() bool {
	switch e.val {
	case DeployStatus_PUBLISHED, DeployStatus_DEPLOYED:
		return false
	}
	return true
}

func (e DeployStatus) Value() DeployStatus_Value {
	if e.IsUnknown() {
		return DeployStatus_UNKNOWN
	}
	return e.val
}

func (e DeployStatus) String() string {
	return string(e.val)
}

func (e DeployStatus) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *DeployStatus) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_DeployStatus(DeployStatus_Value(v))
	case "PUBLISHED":
		*e = New_DeployStatus(DeployStatus_PUBLISHED)
	case "DEPLOYED":
		*e = New_DeployStatus(DeployStatus_DEPLOYED)
	}
	return nil
}

// Action runtime. V1 is AWSLambda@nodejs14.x.
type Runtime struct {
	val Runtime_Value
}

// Action runtime. V1 is AWSLambda@nodejs14.x.
type Runtime_Value string

const (
	Runtime_V1      Runtime_Value = "V1"
	Runtime_V2      Runtime_Value = "V2"
	Runtime_UNKNOWN Runtime_Value = "UNKNOWN"
)

// Runtime_Values returns all known variants of Runtime.
func Runtime_Values() []Runtime_Value {
	return []Runtime_Value{Runtime_V1, Runtime_V2}
}

func New_Runtime(value Runtime_Value) Runtime {
	return Runtime{val: value}
}

// IsUnknown returns false for all known variants of Runtime and true otherwise.
func (e Runtime) IsUnknown() bool {
	switch e.val {
	case Runtime_V1:
		return false
	case Runtime_V2:
		return false
	}
	return true
}

func (e Runtime) Value() Runtime_Value {
	if e.IsUnknown() {
		return Runtime_UNKNOWN
	}
	return e.val
}

func (e Runtime) String() string {
	return string(e.val)
}

func (e Runtime) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *Runtime) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_Runtime(Runtime_Value(v))
	case "V1":
		*e = New_Runtime(Runtime_V1)
	case "V2":
		*e = New_Runtime(Runtime_V2)
	}
	return nil
}

type Status struct {
	val Status_Value
}

type Status_Value string

const (
	Status_SUCCESS Status_Value = "SUCCESS"
	Status_FAIL    Status_Value = "FAIL"
	Status_UNKNOWN Status_Value = "UNKNOWN"
)

// Status_Values returns all known variants of Status.
func Status_Values() []Status_Value {
	return []Status_Value{Status_SUCCESS, Status_FAIL}
}

func New_Status(value Status_Value) Status {
	return Status{val: value}
}

// IsUnknown returns false for all known variants of Status and true otherwise.
func (e Status) IsUnknown() bool {
	switch e.val {
	case Status_SUCCESS, Status_FAIL:
		return false
	}
	return true
}

func (e Status) Value() Status_Value {
	if e.IsUnknown() {
		return Status_UNKNOWN
	}
	return e.val
}

func (e Status) String() string {
	return string(e.val)
}

func (e Status) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *Status) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_Status(Status_Value(v))
	case "SUCCESS":
		*e = New_Status(Status_SUCCESS)
	case "FAIL":
		*e = New_Status(Status_FAIL)
	}
	return nil
}

type TransactionStatus struct {
	val TransactionStatus_Value
}

type TransactionStatus_Value string

const (
	TransactionStatus_MINED       TransactionStatus_Value = "MINED"
	TransactionStatus_CONFIRMED10 TransactionStatus_Value = "CONFIRMED10"
	TransactionStatus_UNKNOWN     TransactionStatus_Value = "UNKNOWN"
)

// TransactionStatus_Values returns all known variants of TransactionStatus.
func TransactionStatus_Values() []TransactionStatus_Value {
	return []TransactionStatus_Value{TransactionStatus_MINED, TransactionStatus_CONFIRMED10}
}

func New_TransactionStatus(value TransactionStatus_Value) TransactionStatus {
	return TransactionStatus{val: value}
}

// IsUnknown returns false for all known variants of TransactionStatus and true otherwise.
func (e TransactionStatus) IsUnknown() bool {
	switch e.val {
	case TransactionStatus_MINED, TransactionStatus_CONFIRMED10:
		return false
	}
	return true
}

func (e TransactionStatus) Value() TransactionStatus_Value {
	if e.IsUnknown() {
		return TransactionStatus_UNKNOWN
	}
	return e.val
}

func (e TransactionStatus) String() string {
	return string(e.val)
}

func (e TransactionStatus) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *TransactionStatus) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_TransactionStatus(TransactionStatus_Value(v))
	case "MINED":
		*e = New_TransactionStatus(TransactionStatus_MINED)
	case "CONFIRMED10":
		*e = New_TransactionStatus(TransactionStatus_CONFIRMED10)
	}
	return nil
}

type TriggerType struct {
	val TriggerType_Value
}

type TriggerType_Value string

const (
	TriggerType_PERIODIC          TriggerType_Value = "PERIODIC"
	TriggerType_WEBHOOK           TriggerType_Value = "WEBHOOK"
	TriggerType_TRANSACTION       TriggerType_Value = "TRANSACTION"
	TriggerType_BLOCK             TriggerType_Value = "BLOCK"
	TriggerType_ALERT             TriggerType_Value = "ALERT"
	TriggerType_TRANSACTIONSIMPLE TriggerType_Value = "TRANSACTIONSIMPLE"
	TriggerType_UNKNOWN           TriggerType_Value = "UNKNOWN"
)

// TriggerType_Values returns all known variants of TriggerType.
func TriggerType_Values() []TriggerType_Value {
	return []TriggerType_Value{TriggerType_PERIODIC, TriggerType_WEBHOOK, TriggerType_TRANSACTION, TriggerType_BLOCK, TriggerType_ALERT, TriggerType_TRANSACTIONSIMPLE}
}

func New_TriggerType(value TriggerType_Value) TriggerType {
	return TriggerType{val: value}
}

// IsUnknown returns false for all known variants of TriggerType and true otherwise.
func (e TriggerType) IsUnknown() bool {
	switch e.val {
	case TriggerType_PERIODIC, TriggerType_WEBHOOK, TriggerType_TRANSACTION, TriggerType_BLOCK, TriggerType_ALERT, TriggerType_TRANSACTIONSIMPLE:
		return false
	}
	return true
}

func (e TriggerType) Value() TriggerType_Value {
	if e.IsUnknown() {
		return TriggerType_UNKNOWN
	}
	return e.val
}

func (e TriggerType) String() string {
	return string(e.val)
}

func (e TriggerType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *TriggerType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_TriggerType(TriggerType_Value(v))
	case "PERIODIC":
		*e = New_TriggerType(TriggerType_PERIODIC)
	case "WEBHOOK":
		*e = New_TriggerType(TriggerType_WEBHOOK)
	case "TRANSACTION":
		*e = New_TriggerType(TriggerType_TRANSACTION)
	case "BLOCK":
		*e = New_TriggerType(TriggerType_BLOCK)
	case "ALERT":
		*e = New_TriggerType(TriggerType_ALERT)
	case "TRANSACTIONSIMPLE":
		*e = New_TriggerType(TriggerType_TRANSACTIONSIMPLE)
	}
	return nil
}
